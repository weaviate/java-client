package io.weaviate.integration;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.List;
import java.util.UUID;

import org.assertj.core.api.Assertions;
import org.junit.Assume;
import org.junit.Test;

import io.weaviate.ConcurrentTest;
import io.weaviate.client6.v1.api.Authentication;
import io.weaviate.client6.v1.internal.TokenProvider;
import io.weaviate.client6.v1.internal.rest.RestTransport;
import io.weaviate.containers.Weaviate;

/**
 * Test that the client can use one of the supported authentication flows to
 * obtain a token from the OIDC provider and use it in a request to Weaviate.
 *
 * Running this test suite successfully requires talking to external services,
 * so tests will be skipped if we don't have internet. See
 * {@link #hasInternetConnection}.
 */
public class OIDCSupportITest extends ConcurrentTest {
  private static final String WCS_DUMMY_CI_USERNAME = "oidc-test-user@weaviate.io";
  private static final String WCS_DUMMY_CI_PW = System.getenv("WCS_DUMMY_CI_PW");

  /**
   * Weaviate container that uses WCS-backed OIDC provider.
   * Supports ResourceOwnerPassword and RefreshToken authentication flows.
   */
  private static final Weaviate wcsContainer = Weaviate.custom()
      .withOIDC("wcs", "https://auth.wcs.api.weaviate.io/auth/realms/SeMI", "email", "groups")
      .build();

  private static final String OKTA_CLIENT_ID = "0oa7e9ipdkVZRUcxo5d7";
  private static final String OKTA_CLIENT_SECRET = System.getenv("OKTA_CLIENT_SECRET");

  /**
   * Weaviate container that uses Okta's dummy OIDC provider.
   * Supports ClientCredentials flow.
   */
  private static final Weaviate oktaContainer = Weaviate.custom()
      .withOIDC(OKTA_CLIENT_ID, "https://dev-32300990.okta.com/oauth2/aus7e9kxbwYQB0eht5d7", "cid", "groups")
      .build();

  @Test
  public void test_bearerToken() throws Exception {
    Assume.assumeTrue("WCS_DUMMY_CI_PW is not set", WCS_DUMMY_CI_PW != null);
    Assume.assumeTrue("no internet connection", hasInternetConnection());

    var t = SpyTokenProvider.stealToken();
    var auth = Authentication.bearerToken(t.accessToken(), t.refreshToken(), t.expiresIn());
    pingWeaviate(wcsContainer, auth);
  }

  @Test
  public void test_resourceOwnerPassword() throws Exception {
    Assume.assumeTrue("WCS_DUMMY_CI_PW is not set", WCS_DUMMY_CI_PW != null);
    Assume.assumeTrue("no internet connection", hasInternetConnection());

    var auth = Authentication.resourceOwnerPassword(WCS_DUMMY_CI_USERNAME, WCS_DUMMY_CI_PW, List.of());
    pingWeaviate(wcsContainer, auth);
  }

  @Test
  public void test_clientCredentials() throws Exception {
    Assume.assumeTrue("OKTA_CLIENT_SECRET is not set", OKTA_CLIENT_SECRET != null);
    Assume.assumeTrue("no internet connection", hasInternetConnection());

    var auth = Authentication.clientCredentials(OKTA_CLIENT_ID, OKTA_CLIENT_SECRET, List.of());
    pingWeaviate(oktaContainer, auth);
  }

  /**
   * Test AuthenticationInterceptor (HTTP) / TokenCallCredentials (gRPC)
   * work correctly in the async context.
   */
  @Test
  public void test_clientCredentials_async() throws Exception {
    Assume.assumeTrue("OKTA_CLIENT_SECRET is not set", OKTA_CLIENT_SECRET != null);
    Assume.assumeTrue("no internet connection", hasInternetConnection());

    var auth = Authentication.clientCredentials(OKTA_CLIENT_ID, OKTA_CLIENT_SECRET, List.of());
    final var client = oktaContainer.getClient(conn -> conn.authentication(auth));
    final var async = client.async();

    try {
      // Make an authenticated REST call
      Assertions.assertThat(async.isLive().get()).isTrue();

      // Make an authenticated gRPC call
      var nsThings = ns("Things");
      async.collections.create(nsThings);
      var things = async.collections.use(nsThings);
      var randomUuid = UUID.randomUUID().toString();
      Assertions.assertThat(things.data.exists(randomUuid).get()).isFalse();
    } catch (Exception e) {
      Assertions.fail(e);
    } finally {
      client.close();
      async.close();
    }
  }

  private static void pingWeaviate(final Weaviate container, Authentication auth) throws Exception {
    try (final var client = container.getClient(conn -> conn.authentication(auth))) {
      Assertions.assertThat(client.isLive()).isTrue();
    }
  }

  private static boolean hasInternetConnection() {
    return ping("www.google.com");
  }

  private static boolean ping(String site) {
    InetSocketAddress addr = new InetSocketAddress(site, 80);
    try (final var sock = new Socket()) {
      sock.connect(addr, 3000);
      return true;
    } catch (IOException e) {
      return false;
    }
  }

  /**
   * SpyTokenProvider is an Authentication implementation that spies on the
   * TokenProvider it creates and can expose tokens generated by it.
   */
  private static class SpyTokenProvider implements Authentication, TokenProvider {

    /** Exchange resource owner password for a token and return it. */
    static Token stealToken() throws Exception {
      var auth = Authentication.resourceOwnerPassword(WCS_DUMMY_CI_USERNAME, WCS_DUMMY_CI_PW, List.of());
      var spy = new SpyTokenProvider(auth);
      pingWeaviate(wcsContainer, spy);
      return spy.getToken();
    }

    private Authentication authentication;
    private TokenProvider tokenProvider;

    private SpyTokenProvider(Authentication actual) {
      this.authentication = actual;
    }

    @Override
    public TokenProvider getTokenProvider(RestTransport transport) {
      tokenProvider = authentication.getTokenProvider(transport);
      return this;
    }

    @Override
    public Token getToken() {
      return tokenProvider.getToken();
    }
  }
}
